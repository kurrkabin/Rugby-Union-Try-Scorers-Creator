# app.py
# Streamlit version of your Bet365 Tryscorers parser (Rugby)
# Output columns: SelectionName | SelectionOdds | FirstOdds | LastOdds | AnyOdds

import re
import io
import pandas as pd
import streamlit as st

st.set_page_config(page_title="Bet365 Tryscorers Parser", layout="wide")

# ---------- Parser helpers ----------
def _norm(text: str) -> list[str]:
    t = re.sub(r'\r\n?', '\n', text)
    t = re.sub(r'\n{2,}', '\n', t)
    return [ln.strip() for ln in t.split('\n') if ln.strip()]

def _idx(lines, token):
    token = token.strip().lower()
    for i, ln in enumerate(lines):
        if ln.strip().lower() == token:
            return i
    return -1

def _collect_names(lines, start, end):
    keep = []
    for ln in lines[start+1:end]:
        if ln in {"BB", "ET Extra Chance"}:
            continue
        # Allow names with diacritics, spaces, apostrophes, dashes, periods, or "No Tryscorer"
        if ln == "No Tryscorer" or re.match(r"^[A-Za-zÀ-ÖØ-öø-ÿ'’.\- ]{2,}$", ln):
            keep.append(ln)
    return keep

def _collect_odds(lines, start, end):
    out = []
    for ln in lines[start+1:end]:
        if re.match(r"^\d+(\.\d+)?$", ln):
            out.append(float(ln))
    return out

def parse_bet365_tryscorers(raw: str) -> pd.DataFrame:
    lines = _norm(raw)
    try_i = _idx(lines, "Tryscorers")
    first_i = _idx(lines, "First")
    last_i  = _idx(lines, "Last")
    any_i   = _idx(lines, "Anytime")

    if min(try_i, first_i, last_i, any_i) == -1:
        raise ValueError("Could not find required headers: Tryscorers / First / Last / Anytime")

    names = _collect_names(lines, try_i, first_i)
    first = _collect_odds(lines, first_i, last_i)
    _last = _collect_odds(lines, last_i, any_i)   # parsed for alignment only (not used)
    anyt  = _collect_odds(lines, any_i, len(lines))

    m = min(len(names), len(first), len(_last), len(anyt))
    df = pd.DataFrame({
        "SelectionName": names[:m],
        "FirstOdds": first[:m],
        "AnyOdds":   anyt[:m],
    })

    # Add LastOdds = FirstOdds and add blank SelectionOdds; reorder columns as requested
    df["LastOdds"] = df["FirstOdds"]
    df.insert(1, "SelectionOdds", "")
    df = df[["SelectionName", "SelectionOdds", "FirstOdds", "LastOdds", "AnyOdds"]]
    return df

# ---------- UI ----------
st.title("Bet365 Tryscorers → Clean 5 Columns")
st.caption("Paste the entire Bet365 page copy → click **Extract** → copy columns or download CSV/XLSX.")

with st.expander("Paste or upload input", expanded=True):
    col1, col2 = st.columns([3, 1], gap="large")
    with col1:
        raw_text = st.text_area(
            "Paste Bet365 blob here",
            value="",
            height=260,
            placeholder="Paste the entire Bet365 page copy here…",
        )
    with col2:
        uploaded = st.file_uploader("…or upload a .txt file", type=["txt"])
        if uploaded is not None and not raw_text.strip():
            raw_text = uploaded.read().decode("utf-8", errors="ignore")

extract = st.button("Extract", type="primary")

if extract:
    if not raw_text.strip():
        st.warning("Paste some Bet365 text or upload a file first.")
    else:
        try:
            df = parse_bet365_tryscorers(raw_text)
        except Exception as e:
            st.error(f"Parse error: {e}")
            df = None

        if df is not None and not df.empty:
            st.success(f"Parsed {len(df)} rows.")
            st.dataframe(df, use_container_width=True, hide_index=True)

            # Copy-friendly vertical text areas
            st.subheader("Quick copy boxes")
            fmt = lambda x: str(x).rstrip('0').rstrip('.') if isinstance(x, float) and x.is_integer() is False else str(x).rstrip('0').rstrip('.') if isinstance(x, float) else str(x)

            colA, colB, colC, colD, colE = st.columns(5)
            colA.text_area("SelectionName", "\n".join(df["SelectionName"].astype(str)), height=260)
            colB.text_area("SelectionOdds", "\n".join(df["SelectionOdds"].astype(str)), height=260)
            colC.text_area("FirstOdds", "\n".join(df["FirstOdds"].map(fmt)), height=260)
            colD.text_area("LastOdds", "\n".join(df["LastOdds"].map(fmt)), height=260)
            colE.text_area("AnyOdds", "\n".join(df["AnyOdds"].map(fmt)), height=260)

            # Downloads (CSV / XLSX) in-memory
            csv_bytes = df.to_csv(index=False).encode("utf-8")
            xlsx_buf = io.BytesIO()
            with pd.ExcelWriter(xlsx_buf, engine="openpyxl") as writer:
                df.to_excel(writer, index=False, sheet_name="Tryscorers")
            xlsx_buf.seek(0)

            dl1, dl2 = st.columns(2)
            dl1.download_button("Download CSV", data=csv_bytes, file_name="bet365_tryscorers.csv", mime="text/csv")
            dl2.download_button("Download XLSX", data=xlsx_buf, file_name="bet365_tryscorers.xlsx",
                                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
